{"ast":null,"code":"import{createContext,useContext,useState}from\"react\";//由此Context來統一儲存身份狀態\n// import jwt from 'jsonwebtoken'\nimport{jwtDecode}from'jwt-decode';import{useLocation}from\"react-router-dom\";import{useEffect}from\"react\";import{signup,login,checkPermission}from\"../api/auth\";import{jsx as _jsx}from\"react/jsx-runtime\";const defaultAuthContext={isAuthenticated:false,//判斷使用者是否具有有效憑證, 預設是false, 當取得有效憑證(註冊成功或登入成功)則切換為true \ncurrentMember:null,// 當前使用者資料, 預設為null, 成功登入後就會有使用者資料\nsignup:null,//註冊方法\nlogin:null,//登入方法\nlogout:null//登出方法\n};const AuthContext=/*#__PURE__*/createContext(defaultAuthContext);//建立AuthProvider管理狀態,回傳能讓子元件共用的<AuthContext.Provider>\n//輸出context hook \nexport const useAuth=()=>useContext(AuthContext);export const AuthProvider=_ref=>{let{children}=_ref;const[isAuthenticated,setIsAuthenticated]=useState(false);//存打api回來的狀態\nconst[payload,setPayload]=useState(null);//這個payload存打api回來的authToken\n//把判斷身份是否有效的useEffect搬進來\nconst{pathname}=useLocation();useEffect(()=>{const CheckTokenIsValid=async()=>{const authToken=localStorage.getItem(\"authToken\");//如果沒有authToken, 停止檢查, 停留此頁\nif(!authToken){console.log(\"authToken is not existed!\");setIsAuthenticated(false);setPayload(null);return;}const isValid=await checkPermission(authToken);// 傳入 authToken 字串\nif(isValid){setIsAuthenticated(true);const tempPayload=jwtDecode(authToken);setPayload(tempPayload);}else{setIsAuthenticated(false);setPayload(null);console.log(\"Invalid auth token\");}};CheckTokenIsValid();},[pathname]);//只要state狀態更新,接連更新provider所帶的value值\nreturn/*#__PURE__*/_jsx(AuthContext.Provider,{value:{isAuthenticated,currentMember:payload&&{id:payload.sub,name:payload.name},//因為authContext不會知道註冊表單輸入的值,補上data作為調用選項\nsignup:async data=>{const{success,authToken}=await signup({username:data.username,email:data.email,password:data.password});const tempPayload=jwtDecode(authToken);//先確認payload是否存在, 存在才代表登入有效, 就存起來\nif(tempPayload){setPayload(tempPayload);setIsAuthenticated(true);//註冊成功\nlocalStorage.setItem(\"authToken\",authToken);}else{setPayload(null);setIsAuthenticated(false);}return success;},login:async data=>{const{success,authToken}=await login({username:data.username,password:data.password});if(authToken){const tempPayload=jwtDecode(authToken);setPayload(tempPayload);setIsAuthenticated(true);localStorage.setItem(\"authToken\",authToken);// 確保正確儲存\n}else{setPayload(null);setIsAuthenticated(false);}return success;},logout:()=>{localStorage.removeItem(\"authToken\");setIsAuthenticated(false);setPayload(null);}},children:children});};","map":{"version":3,"names":["createContext","useContext","useState","jwtDecode","useLocation","useEffect","signup","login","checkPermission","jsx","_jsx","defaultAuthContext","isAuthenticated","currentMember","logout","AuthContext","useAuth","AuthProvider","_ref","children","setIsAuthenticated","payload","setPayload","pathname","CheckTokenIsValid","authToken","localStorage","getItem","console","log","isValid","tempPayload","Provider","value","id","sub","name","data","success","username","email","password","setItem","removeItem"],"sources":["/Users/huang/todolist-react-starter/src/contexts/AuthContext.jsx"],"sourcesContent":["import { createContext, useContext, useState } from \"react\"\n//由此Context來統一儲存身份狀態\n// import jwt from 'jsonwebtoken'\nimport { jwtDecode } from 'jwt-decode'\nimport { useLocation } from \"react-router-dom\"\nimport { useEffect } from \"react\"\nimport { signup, login, checkPermission } from \"../api/auth\"\n\nconst defaultAuthContext = {\n  isAuthenticated: false, //判斷使用者是否具有有效憑證, 預設是false, 當取得有效憑證(註冊成功或登入成功)則切換為true \n  currentMember: null, // 當前使用者資料, 預設為null, 成功登入後就會有使用者資料\n  signup: null, //註冊方法\n  login: null, //登入方法\n  logout: null //登出方法\n}\n\nconst AuthContext = createContext(defaultAuthContext)\n\n//建立AuthProvider管理狀態,回傳能讓子元件共用的<AuthContext.Provider>\n\n//輸出context hook \nexport const useAuth = () => useContext(AuthContext);\nexport const AuthProvider = ({children}) => {\n  const [isAuthenticated, setIsAuthenticated]=useState(false) //存打api回來的狀態\n  const [payload, setPayload]=useState(null)//這個payload存打api回來的authToken\n\n  //把判斷身份是否有效的useEffect搬進來\n  const {pathname} = useLocation()\n\n    useEffect(() => {\n      const CheckTokenIsValid = async() => {\n        const authToken = localStorage.getItem(\"authToken\");\n\n        //如果沒有authToken, 停止檢查, 停留此頁\n        if (!authToken) {\n          console.log(\"authToken is not existed!\")\n          setIsAuthenticated(false)\n          setPayload(null)\n          return;\n        }\n\n        const isValid = await checkPermission(authToken); // 傳入 authToken 字串\n        if (isValid) {\n          setIsAuthenticated(true);\n          const tempPayload = jwtDecode(authToken);\n          setPayload(tempPayload);\n        } else {\n          setIsAuthenticated(false);\n          setPayload(null);\n          console.log(\"Invalid auth token\");\n        }\n      }\n\n      CheckTokenIsValid();\n    }, [pathname]);\n\n\n   //只要state狀態更新,接連更新provider所帶的value值\n  return (\n    <AuthContext.Provider\n      value={{\n        isAuthenticated,\n        currentMember: payload && {\n          id: payload.sub,\n          name: payload.name,\n        },\n        //因為authContext不會知道註冊表單輸入的值,補上data作為調用選項\n        signup: async (data) => {\n          const { success, authToken } = await signup({\n            username: data.username,\n            email: data.email,\n            password: data.password,\n          });\n          const tempPayload = jwtDecode(authToken);\n          //先確認payload是否存在, 存在才代表登入有效, 就存起來\n          if (tempPayload) {\n            setPayload(tempPayload);\n            setIsAuthenticated(true); //註冊成功\n            localStorage.setItem(\"authToken\", authToken);\n          } else {\n            setPayload(null);\n            setIsAuthenticated(false);\n          }\n          return success;\n        },\n        login: async (data) => {\n          const { success, authToken } = await login({\n            username: data.username,\n            password: data.password,\n          });\n\n          if (authToken) {\n            const tempPayload = jwtDecode(authToken);\n            setPayload(tempPayload);\n            setIsAuthenticated(true);\n            localStorage.setItem(\"authToken\", authToken); // 確保正確儲存\n          } else {\n            setPayload(null);\n            setIsAuthenticated(false);\n          }\n          return success;\n        },\n        logout: () => {\n          localStorage.removeItem(\"authToken\");\n          setIsAuthenticated(false);\n          setPayload(null);\n        },\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}